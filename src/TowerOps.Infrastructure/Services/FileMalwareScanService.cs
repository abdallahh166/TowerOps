using System.Buffers.Binary;
using System.Net.Sockets;
using System.Text;
using Microsoft.Extensions.Logging;
using TowerOps.Application.Common.Interfaces;

namespace TowerOps.Infrastructure.Services;

public sealed class FileMalwareScanService : IFileMalwareScanService
{
    private const int DefaultPort = 3310;
    private const int DefaultTimeoutSeconds = 10;

    private readonly IFileStorageService _fileStorageService;
    private readonly ISystemSettingsService _settingsService;
    private readonly ILogger<FileMalwareScanService> _logger;

    public FileMalwareScanService(
        IFileStorageService fileStorageService,
        ISystemSettingsService settingsService,
        ILogger<FileMalwareScanService> logger)
    {
        _fileStorageService = fileStorageService;
        _settingsService = settingsService;
        _logger = logger;
    }

    public async Task<FileMalwareScanResult> ScanAsync(
        string fileName,
        string filePath,
        CancellationToken cancellationToken = default)
    {
        var provider = await _settingsService.GetAsync(
            "UploadSecurity:MalwareScan:Provider",
            "ClamAV",
            cancellationToken);

        await using var fileStream = await _fileStorageService.DownloadFileAsync(filePath, cancellationToken);
        if (fileStream is null)
            return new FileMalwareScanResult(false, "Failed to load file from storage for malware scan.");

        if (string.Equals(provider, "ClamAV", StringComparison.OrdinalIgnoreCase))
        {
            return await ScanWithClamAvAsync(fileName, fileStream, cancellationToken);
        }

        if (string.Equals(provider, "AzureDefender", StringComparison.OrdinalIgnoreCase))
        {
            return new FileMalwareScanResult(false, "Azure Defender scanner integration is not configured.");
        }

        _logger.LogWarning(
            "Unknown malware scan provider '{Provider}'. Quarantining upload by fail-safe policy.",
            provider);

        return new FileMalwareScanResult(false, $"Unknown malware scan provider: {provider}");
    }

    private async Task<FileMalwareScanResult> ScanWithClamAvAsync(
        string fileName,
        Stream fileStream,
        CancellationToken cancellationToken)
    {
        var host = await _settingsService.GetAsync(
            "UploadSecurity:ClamAV:Host",
            string.Empty,
            cancellationToken);

        if (string.IsNullOrWhiteSpace(host))
        {
            return new FileMalwareScanResult(false, "ClamAV host is not configured.");
        }

        var port = await _settingsService.GetAsync(
            "UploadSecurity:ClamAV:Port",
            DefaultPort,
            cancellationToken);

        var timeoutSeconds = await _settingsService.GetAsync(
            "UploadSecurity:ClamAV:TimeoutSeconds",
            DefaultTimeoutSeconds,
            cancellationToken);

        using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        timeoutCts.CancelAfter(TimeSpan.FromSeconds(Math.Clamp(timeoutSeconds, 1, 120)));

        try
        {
            using var client = new TcpClient();
            await client.ConnectAsync(host, port, timeoutCts.Token);

            await using var network = client.GetStream();
            await SendCommandAsync(network, "zINSTREAM\0", timeoutCts.Token);
            await StreamFileAsync(network, fileStream, timeoutCts.Token);

            var response = await ReadResponseAsync(network, timeoutCts.Token);
            if (response.Contains("FOUND", StringComparison.OrdinalIgnoreCase))
            {
                return new FileMalwareScanResult(false, $"Malware detected by ClamAV for {fileName}: {response}");
            }

            if (response.Contains("OK", StringComparison.OrdinalIgnoreCase))
            {
                return new FileMalwareScanResult(true, "ClamAV scan clean.");
            }

            return new FileMalwareScanResult(false, $"Unexpected ClamAV response: {response}");
        }
        catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested && !cancellationToken.IsCancellationRequested)
        {
            return new FileMalwareScanResult(false, "ClamAV scan timed out.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ClamAV scan failed for {FileName}.", fileName);
            return new FileMalwareScanResult(false, $"ClamAV scan failed: {ex.Message}");
        }
    }

    private static async Task SendCommandAsync(NetworkStream stream, string command, CancellationToken cancellationToken)
    {
        var bytes = Encoding.ASCII.GetBytes(command);
        await stream.WriteAsync(bytes, cancellationToken);
    }

    private static async Task StreamFileAsync(NetworkStream network, Stream fileStream, CancellationToken cancellationToken)
    {
        if (fileStream.CanSeek)
            fileStream.Seek(0, SeekOrigin.Begin);

        var buffer = new byte[8192];
        int read;
        while ((read = await fileStream.ReadAsync(buffer.AsMemory(0, buffer.Length), cancellationToken)) > 0)
        {
            var lengthPrefix = new byte[4];
            BinaryPrimitives.WriteInt32BigEndian(lengthPrefix, read);
            await network.WriteAsync(lengthPrefix.AsMemory(0, 4), cancellationToken);
            await network.WriteAsync(buffer.AsMemory(0, read), cancellationToken);
        }

        var zeroPrefix = new byte[4];
        BinaryPrimitives.WriteInt32BigEndian(zeroPrefix, 0);
        await network.WriteAsync(zeroPrefix.AsMemory(0, 4), cancellationToken);
        await network.FlushAsync(cancellationToken);
    }

    private static async Task<string> ReadResponseAsync(NetworkStream network, CancellationToken cancellationToken)
    {
        using var ms = new MemoryStream();
        var buffer = new byte[256];

        int read;
        do
        {
            read = await network.ReadAsync(buffer.AsMemory(0, buffer.Length), cancellationToken);
            if (read > 0)
                ms.Write(buffer, 0, read);
        } while (read > 0 && !buffer[..read].Contains((byte)0));

        return Encoding.ASCII.GetString(ms.ToArray()).Trim('\0', '\r', '\n', ' ');
    }
}
